<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            垃圾回收机制(又称为垃圾回收器)
                它可以用于判断内存中某个数据是否还在被其他人使用,
                如果没有人使用,那么就回收该数据使用的内存

            基本数据类型的数据,会随着存储数据的对象一起销毁

            早期版本:引用计数法
                给每个对象添加标识,记录当前对象的使用次数
                通过给对象添加count属性,来记录一个对象到底还有多少人正在引用他
                    有人引用某个对象,那么对象的count+1
                    有人解绑对某个对象的引用,那么对象的count-1
                    最终,如果count为0,就说明该对象需要被回收

                漏洞:如果出现多个对象循环引用对方,那么很可能出现这些对象的count无法归零
                    最终导致这些对象本该被回收,但是没被回收

                早期的浏览器使用的都是这个版本,特别是IE

            最新版本:Scanvager算法
                他一共分为两个区域
                新生代区
                    新生代区中,存储当前新创建的对象
                    新生代区中,又分为两个数组,分别是from和to
                    准备工作:
                        第一次会先进行全盘扫描,从window对象开始扫描他身上的所有属性
                            如果发现是对象,就会将该对象存入到from数组中,然后继续递归扫描
                            直到所有的属性全部扫描结束,此时from数组中会存放所有的对象
                    流程:
                        1.从window对象开始,扫描他身上的所有属性
                        2.遇到对象时,就将这个对象从from数组移到to数组中进行存储
                        3.以此规律继续递归扫描剩余的所有属性,直到所有属性都结束为止
                        4.扫描结束之后,会将from数组进行清空,那么没有在to数组中的对象就会被释放
                        5.最终,当from数组清空之后,to数组和from数组对调,
                            to数组成为新的from数组,from数组成为新的to数组

                    注意:当一个对象出现在to数组中三次及以上,那么该对象就会被放入老生代区

                    算法:以空间换时间

                老生代区
                    老生代区中,存储当前创建比较久的对象
                    老生代区只有一个数组,内部会存放创建时间比较久的对象
                    流程:
                        1.从window对象开始扫描,扫描他身上的所有属性(这步操作是与新生代区一起)
                        2.如果遇到某个对象,该对象存储于老生代区,老生代区中该对象会被打上标记
                            标记的意思是说,当前对象还在被使用
                        3.当所有的属性都被扫描结束之后,老生代区要开启自己的数组扫描
                        4.开始遍历老生代区的数组,如果遇到了没有标记的对象,那么该对象就会被进行回收
                            如果有标记的,就将标记清空,并且保留该对象
                        5.最终,还需要整理零散的内存空间,方便后续存储数据

                    算法:以时间换空间

        */

        //--------------------------
        // var obj = 0x001;
        // var obj = {};
        // var obj2 = obj;

        // obj = null;
        // obj2 = null;
        // console.log(obj === obj2)

        //--------------------------
        // 计数法的漏洞

        // var obj1 = {
        //     name:"xiaoming"
        // }

        // var obj2 = {
        //     name:"xiaohong"
        // }

        // obj1.a = obj2;
        // obj2.a = obj1;
        // // 到目前为止,一切正常,两个对象都被引用了两次,所以他们的count都为2

        // obj1 = null;
        // obj2 = null;
        // // 代码中已经将能够获取这两个对象的手段释放掉了,但是这两个对象还在循环引用对方
        // // 结果导致count无法归零,最终这两个对象都不会被回收

        //--------------------
        var obj = {
            a:{
                d:{
                    f:{

                    },
                    g:{

                    }
                }
            },
            b:{
                e:{

                }
            },
            c:{}
        }

        obj.c = null;
        obj.a.d = null;


    </script>
</body>
</html>